package orpheus.graphics {	import flash.geom.ColorTransform;		import flash.display.Bitmap;		import flash.display.DisplayObject;		import flash.display.BitmapData;		import flash.display.JointStyle;		import flash.display.CapsStyle;		import flash.display.LineScaleMode;		import caurina.transitions.Tweener;		import flash.filters.BlurFilter;		import flash.events.Event;		import flash.geom.Point;		import flash.events.MouseEvent;		import flash.display.Sprite;	/**	 * @author philip	 */	public class CurveDraw extends Sprite 	{		private var _color:uint = 0x000000;		private var _alpha:Number = 1;		private var _spiral:Number = 0.1;		public var _thickness:Number = 0;		public var _tweenThickness:Number = 0;		private var p1:Array = new Array();		private var p2:Array = new Array();		private var p3:Array = new Array();		private var en:Array = new Array();		private var ax:Array = new Array();		private var ay:Array = new Array();		private var r:Array = new Array();		private var f:Array = new Array();		public var drawArr:Array;		public static const FINISH_DRAW:String = "FINISH_DRAW";		public static const START_DRAW:String = "START_DRAW";		private var autoStart:Boolean;		private var _enable:Boolean;		private var _penSpeed:Boolean;		private var canvas:Sprite;		private var _useBitmap:Boolean;		private var bmData:BitmapData;		private var bitmap:DisplayObject;		private var _lines:uint;		private var _force:Number = 0.5;		public function CurveDraw(autoStart:Boolean = true, penSpeedEnable:Boolean = true, bitmap:Boolean = true, lineNum:uint = 1)		{						canvas = new Sprite();			if (!_useBitmap) 			{				addChild(canvas);			}						penSpeed = penSpeedEnable;			this.autoStart = autoStart;			_useBitmap = bitmap;			_lines = lineNum;						addEventListener(Event.ADDED_TO_STAGE, initialize);		}		private function initialize(event:Event):void		{			for(var i:uint = 0; i < _lines; i++)			{				p1[i] = new Point();				p2[i] = new Point();				p3[i] = new Point();				en[i] = new Point();								sprialSetting(i);							}						if (autoStart) enable = true;			if (_useBitmap)			{				bmData = new BitmapData(stage.stageWidth, stage.stageHeight, true, 0);				bitmap = new Bitmap(bmData);				addChild(bitmap);			}		}				private function sprialSetting(i:uint):void		{			if (lines == 1)			{				r[i] = 0.5;			}			else			{				r[i] = ((i + 1) * (spiral + Math.random() * spiral * .1));			}					}		private function mouseEventHandler( e:MouseEvent ):void		{			switch( e.type )			{				case MouseEvent.MOUSE_DOWN :					reSetting();					beginDraw();					break;								case MouseEvent.MOUSE_MOVE :					draw();					break;								case MouseEvent.MOUSE_UP :					endDraw();					break;			}		}		private function beginDraw():void		{			_tweenThickness = 0;			Tweener.removeTweens(this);			dispatchEvent(new Event(START_DRAW));			drawArr = new Array();						for(var i:uint = 0; i < lines; i++)			{				p3[i].x = mouseX;				p3[i].y = mouseY;				p2[i] = p3[i].clone();				p1[i] = p3[i].clone();				en[i] = p3[i].clone();				ax[i] = 0;				ay[i] = 0;			}			canvas.graphics.lineStyle(_thickness, _color, _alpha, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);			drawArr.push(p3[0].clone());						stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseEventHandler);			stage.addEventListener(MouseEvent.MOUSE_UP, mouseEventHandler);		}		private function draw():void		{			for(var i:uint = 0; i < lines; i++)			{				canvas.graphics.moveTo(en[i].x, en[i].y);								ax[i] = (ax[i] + (p3[i].x - mouseX) * r[i]) * force;				ay[i] = (ay[i] + (p3[i].y - mouseY) * r[i]) * force;								p1[i] = p2[i].clone();				p2[i] = p3[i].clone();								p3[i].x = p3[i].x - ax[i];				p3[i].y = p3[i].y - ay[i];				en[i] = Point.interpolate(p2[i], p3[i], .5);							if (i == 0)				{					if (_penSpeed)					{						var _thick:Number = Point.distance(p3[i], p2[i]) * 0.2;						Tweener.addTween(this, {_tweenThickness:_thick, time:2, transition:"easeInNone"});						canvas.graphics.lineStyle(_tweenThickness, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);					}					else					{						canvas.graphics.lineStyle(_thickness, _color, 1, false, LineScaleMode.NORMAL, CapsStyle.ROUND, JointStyle.ROUND);					}				}								canvas.graphics.curveTo(p2[i].x, p2[i].y, en[i].x, en[i].y);							}						if (_useBitmap)			{				var colorTrans:ColorTransform = new ColorTransform();				colorTrans.alphaMultiplier = _alpha;				bmData.draw(canvas, null, colorTrans);				canvas.graphics.clear();			}						drawArr.push(en[Math.floor(_lines * .5)].clone());		}		private function endDraw():void		{			dispatchEvent(new Event(FINISH_DRAW));			stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseEventHandler);			stage.removeEventListener(MouseEvent.MOUSE_UP, mouseEventHandler);		}		/**		 * 그리기 시작 종료 설정		 */		public function get enable():Boolean		{			return _enable;		}		public function set enable(b:Boolean):void		{			if (stage == null) 			{				trace("객체가 컨테이너에 addChil되지 않았습니다.");				return;			}						if (b) stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseEventHandler);			else stage.removeEventListener(MouseEvent.MOUSE_DOWN, mouseEventHandler);						_enable = enable;		}		/**		 * 펜 속도에 따라 라인 두께 변형		 */		public function get penSpeed():Boolean		{			return _penSpeed;		}		public function set penSpeed(pen:Boolean):void		{			if (pen)			{				canvas.filters = [new BlurFilter(1.2, 1.2, 1)];			}			else			{				Tweener.addTween(this, {_thickness:0});				canvas.filters = [];			}			_penSpeed = pen;		}		/**		 * 라인 두께(고장값으로 속도변형 라인설정시 무시됨)		 */		public function get thickness():Number		{			return _thickness;		}		public function set thickness(thick:Number):void		{			_thickness = thick;		}				/**		 * 그림 지우기		 */		public function clear():void		{			if (_useBitmap) bmData.fillRect(bmData.rect, 0);			else canvas.graphics.clear();		}				/**		 * 라인 수		 */		public function get lines():uint		{			return _lines;		}				public function set lines(lines:uint):void		{			_lines = lines;		}				/**		 * 알파 값		 */		public function get lineAlpha():Number		{			return _alpha;		}				public function set lineAlpha(num:Number):void		{			this._alpha = num;		}				/**		 * 비트맵에 그릴 것인지 설정 (true : 비트맵 , false : 벡터)		 */		public function get useBitmap():Boolean		{			return _useBitmap;		}				public function set useBitmap(useBitmap:Boolean):void		{			_useBitmap = useBitmap;		}				/**		 *  회전시 변형 크기 클수록 움직임이 클때 간격이 멀어짐, 선이 하나일때는 의미 없음		 */		public function get spiral():Number		{			return _spiral;		}				public function set spiral(num:Number):void		{			_spiral = num / 10;			reSetting();		}				/**		 * 기본 0.5, 값에 따라서 선의 모양이 뒤틀어질 수 있음, 선이 하나일때는 의미 없음		 */		public function get force():Number		{			return _force;		}				public function set force(force:Number):void		{			_force = force;		}				private function reSetting():void		{			for(var i:uint = 0; i < _lines; i++)			{				sprialSetting(i);			}		}	}}