package orpheus.utils{	import flash.utils.Timer;	import flash.utils.getTimer;	public class Timer extends flash.utils.Timer	{		private var _desiredDelay:Number;		private var _initStart:Number;   		private var _stop:Number;   		private var _start:Number;   		private var _pauses:Number;   				public function Timer(delay:Number, repeatCount:int=0.0)		{			_desiredDelay = delay;			_initStart = 0;			_start = 0;			_stop = 0;			_pauses = 0;			super(delay, repeatCount);		}		public function set desiredDelay(value:Number):void{ _desiredDelay = value;}				/**		 * Manage the timer drift and account for pauses caused by stopping and starting the Timer		 */		public function adjustDelay():void{			//Aggregate pauses. 			//When start and stop are called internally in flash.utils.Timer _start will equal _stop			_pauses += _start - _stop;						/* trace("***** Timer:adjustDelay() istart " + _initStart + " time " + getTimer() 			+ " stop " + _stop + " start " + _start + " pause aggregate "+_pauses);  */						var elapsed:Number = ( getTimer() - _initStart) - _pauses;			var desiredElapsed:Number = ( this.currentCount * _desiredDelay );			var offset:Number = elapsed - desiredElapsed;			var newDelay:Number = _desiredDelay  - offset;						//Setting negetive values for delay will cause an error 			this.delay = newDelay > 0 ? newDelay : _desiredDelay;		}		override public function start():void{			//Set _initStart once only otherwise set a value for when Timer.start() is called			if(_initStart == 0)				_initStart = getTimer();			else				_start = getTimer();			super.start();		}		override public function stop():void{			//Only set the stop value if the Timer has been started			//and needs to be stopped i.e. is running			if(_initStart != 0 && this.running)				_stop = getTimer();			super.stop();		}		override public function reset():void{			_initStart = 0;			_start = 0;			_stop = 0;			_pauses = 0;			super.reset();		}	}}